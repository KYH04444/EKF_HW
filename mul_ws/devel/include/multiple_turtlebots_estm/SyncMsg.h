// Generated by gencpp from file multiple_turtlebots_estm/SyncMsg.msg
// DO NOT EDIT!


#ifndef MULTIPLE_TURTLEBOTS_ESTM_MESSAGE_SYNCMSG_H
#define MULTIPLE_TURTLEBOTS_ESTM_MESSAGE_SYNCMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace multiple_turtlebots_estm
{
template <class ContainerAllocator>
struct SyncMsg_
{
  typedef SyncMsg_<ContainerAllocator> Type;

  SyncMsg_()
    : header()
    , odom_x(0.0)
    , odom_y(0.0)
    , odom_theta(0.0)
    , meas_rho(0.0)
    , meas_beta(0.0)
    , meas_theta(0.0)
    , delta_t(0.0)
    , gt_rho(0.0)
    , gt_beta(0.0)
    , gt_theta(0.0)
    , case0_x(0.0)
    , case0_y(0.0)
    , case0_t(0.0)
    , case1_x(0.0)
    , case1_y(0.0)
    , case1_t(0.0)
    , case2_x(0.0)
    , case2_y(0.0)
    , case2_t(0.0)
    , case3_x(0.0)
    , case3_y(0.0)
    , case3_t(0.0)
    , case4_x(0.0)
    , case4_y(0.0)
    , case4_t(0.0)
    , case4_vj(0.0)
    , case4_wj(0.0)  {
    }
  SyncMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , odom_x(0.0)
    , odom_y(0.0)
    , odom_theta(0.0)
    , meas_rho(0.0)
    , meas_beta(0.0)
    , meas_theta(0.0)
    , delta_t(0.0)
    , gt_rho(0.0)
    , gt_beta(0.0)
    , gt_theta(0.0)
    , case0_x(0.0)
    , case0_y(0.0)
    , case0_t(0.0)
    , case1_x(0.0)
    , case1_y(0.0)
    , case1_t(0.0)
    , case2_x(0.0)
    , case2_y(0.0)
    , case2_t(0.0)
    , case3_x(0.0)
    , case3_y(0.0)
    , case3_t(0.0)
    , case4_x(0.0)
    , case4_y(0.0)
    , case4_t(0.0)
    , case4_vj(0.0)
    , case4_wj(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _odom_x_type;
  _odom_x_type odom_x;

   typedef double _odom_y_type;
  _odom_y_type odom_y;

   typedef double _odom_theta_type;
  _odom_theta_type odom_theta;

   typedef double _meas_rho_type;
  _meas_rho_type meas_rho;

   typedef double _meas_beta_type;
  _meas_beta_type meas_beta;

   typedef double _meas_theta_type;
  _meas_theta_type meas_theta;

   typedef double _delta_t_type;
  _delta_t_type delta_t;

   typedef double _gt_rho_type;
  _gt_rho_type gt_rho;

   typedef double _gt_beta_type;
  _gt_beta_type gt_beta;

   typedef double _gt_theta_type;
  _gt_theta_type gt_theta;

   typedef double _case0_x_type;
  _case0_x_type case0_x;

   typedef double _case0_y_type;
  _case0_y_type case0_y;

   typedef double _case0_t_type;
  _case0_t_type case0_t;

   typedef double _case1_x_type;
  _case1_x_type case1_x;

   typedef double _case1_y_type;
  _case1_y_type case1_y;

   typedef double _case1_t_type;
  _case1_t_type case1_t;

   typedef double _case2_x_type;
  _case2_x_type case2_x;

   typedef double _case2_y_type;
  _case2_y_type case2_y;

   typedef double _case2_t_type;
  _case2_t_type case2_t;

   typedef double _case3_x_type;
  _case3_x_type case3_x;

   typedef double _case3_y_type;
  _case3_y_type case3_y;

   typedef double _case3_t_type;
  _case3_t_type case3_t;

   typedef double _case4_x_type;
  _case4_x_type case4_x;

   typedef double _case4_y_type;
  _case4_y_type case4_y;

   typedef double _case4_t_type;
  _case4_t_type case4_t;

   typedef double _case4_vj_type;
  _case4_vj_type case4_vj;

   typedef double _case4_wj_type;
  _case4_wj_type case4_wj;





  typedef boost::shared_ptr< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> const> ConstPtr;

}; // struct SyncMsg_

typedef ::multiple_turtlebots_estm::SyncMsg_<std::allocator<void> > SyncMsg;

typedef boost::shared_ptr< ::multiple_turtlebots_estm::SyncMsg > SyncMsgPtr;
typedef boost::shared_ptr< ::multiple_turtlebots_estm::SyncMsg const> SyncMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator1> & lhs, const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.odom_x == rhs.odom_x &&
    lhs.odom_y == rhs.odom_y &&
    lhs.odom_theta == rhs.odom_theta &&
    lhs.meas_rho == rhs.meas_rho &&
    lhs.meas_beta == rhs.meas_beta &&
    lhs.meas_theta == rhs.meas_theta &&
    lhs.delta_t == rhs.delta_t &&
    lhs.gt_rho == rhs.gt_rho &&
    lhs.gt_beta == rhs.gt_beta &&
    lhs.gt_theta == rhs.gt_theta &&
    lhs.case0_x == rhs.case0_x &&
    lhs.case0_y == rhs.case0_y &&
    lhs.case0_t == rhs.case0_t &&
    lhs.case1_x == rhs.case1_x &&
    lhs.case1_y == rhs.case1_y &&
    lhs.case1_t == rhs.case1_t &&
    lhs.case2_x == rhs.case2_x &&
    lhs.case2_y == rhs.case2_y &&
    lhs.case2_t == rhs.case2_t &&
    lhs.case3_x == rhs.case3_x &&
    lhs.case3_y == rhs.case3_y &&
    lhs.case3_t == rhs.case3_t &&
    lhs.case4_x == rhs.case4_x &&
    lhs.case4_y == rhs.case4_y &&
    lhs.case4_t == rhs.case4_t &&
    lhs.case4_vj == rhs.case4_vj &&
    lhs.case4_wj == rhs.case4_wj;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator1> & lhs, const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace multiple_turtlebots_estm

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e6952c1e230cf227605592ba046a70b4";
  }

  static const char* value(const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe6952c1e230cf227ULL;
  static const uint64_t static_value2 = 0x605592ba046a70b4ULL;
};

template<class ContainerAllocator>
struct DataType< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "multiple_turtlebots_estm/SyncMsg";
  }

  static const char* value(const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"float64 odom_x\n"
"float64 odom_y\n"
"float64 odom_theta\n"
"float64 meas_rho\n"
"float64 meas_beta\n"
"float64 meas_theta\n"
"float64 delta_t\n"
"float64 gt_rho\n"
"float64 gt_beta\n"
"float64 gt_theta\n"
"float64 case0_x\n"
"float64 case0_y\n"
"float64 case0_t\n"
"float64 case1_x\n"
"float64 case1_y\n"
"float64 case1_t\n"
"float64 case2_x\n"
"float64 case2_y\n"
"float64 case2_t\n"
"float64 case3_x\n"
"float64 case3_y\n"
"float64 case3_t\n"
"float64 case4_x\n"
"float64 case4_y\n"
"float64 case4_t\n"
"float64 case4_vj\n"
"float64 case4_wj\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.odom_x);
      stream.next(m.odom_y);
      stream.next(m.odom_theta);
      stream.next(m.meas_rho);
      stream.next(m.meas_beta);
      stream.next(m.meas_theta);
      stream.next(m.delta_t);
      stream.next(m.gt_rho);
      stream.next(m.gt_beta);
      stream.next(m.gt_theta);
      stream.next(m.case0_x);
      stream.next(m.case0_y);
      stream.next(m.case0_t);
      stream.next(m.case1_x);
      stream.next(m.case1_y);
      stream.next(m.case1_t);
      stream.next(m.case2_x);
      stream.next(m.case2_y);
      stream.next(m.case2_t);
      stream.next(m.case3_x);
      stream.next(m.case3_y);
      stream.next(m.case3_t);
      stream.next(m.case4_x);
      stream.next(m.case4_y);
      stream.next(m.case4_t);
      stream.next(m.case4_vj);
      stream.next(m.case4_wj);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SyncMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::multiple_turtlebots_estm::SyncMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "odom_x: ";
    Printer<double>::stream(s, indent + "  ", v.odom_x);
    s << indent << "odom_y: ";
    Printer<double>::stream(s, indent + "  ", v.odom_y);
    s << indent << "odom_theta: ";
    Printer<double>::stream(s, indent + "  ", v.odom_theta);
    s << indent << "meas_rho: ";
    Printer<double>::stream(s, indent + "  ", v.meas_rho);
    s << indent << "meas_beta: ";
    Printer<double>::stream(s, indent + "  ", v.meas_beta);
    s << indent << "meas_theta: ";
    Printer<double>::stream(s, indent + "  ", v.meas_theta);
    s << indent << "delta_t: ";
    Printer<double>::stream(s, indent + "  ", v.delta_t);
    s << indent << "gt_rho: ";
    Printer<double>::stream(s, indent + "  ", v.gt_rho);
    s << indent << "gt_beta: ";
    Printer<double>::stream(s, indent + "  ", v.gt_beta);
    s << indent << "gt_theta: ";
    Printer<double>::stream(s, indent + "  ", v.gt_theta);
    s << indent << "case0_x: ";
    Printer<double>::stream(s, indent + "  ", v.case0_x);
    s << indent << "case0_y: ";
    Printer<double>::stream(s, indent + "  ", v.case0_y);
    s << indent << "case0_t: ";
    Printer<double>::stream(s, indent + "  ", v.case0_t);
    s << indent << "case1_x: ";
    Printer<double>::stream(s, indent + "  ", v.case1_x);
    s << indent << "case1_y: ";
    Printer<double>::stream(s, indent + "  ", v.case1_y);
    s << indent << "case1_t: ";
    Printer<double>::stream(s, indent + "  ", v.case1_t);
    s << indent << "case2_x: ";
    Printer<double>::stream(s, indent + "  ", v.case2_x);
    s << indent << "case2_y: ";
    Printer<double>::stream(s, indent + "  ", v.case2_y);
    s << indent << "case2_t: ";
    Printer<double>::stream(s, indent + "  ", v.case2_t);
    s << indent << "case3_x: ";
    Printer<double>::stream(s, indent + "  ", v.case3_x);
    s << indent << "case3_y: ";
    Printer<double>::stream(s, indent + "  ", v.case3_y);
    s << indent << "case3_t: ";
    Printer<double>::stream(s, indent + "  ", v.case3_t);
    s << indent << "case4_x: ";
    Printer<double>::stream(s, indent + "  ", v.case4_x);
    s << indent << "case4_y: ";
    Printer<double>::stream(s, indent + "  ", v.case4_y);
    s << indent << "case4_t: ";
    Printer<double>::stream(s, indent + "  ", v.case4_t);
    s << indent << "case4_vj: ";
    Printer<double>::stream(s, indent + "  ", v.case4_vj);
    s << indent << "case4_wj: ";
    Printer<double>::stream(s, indent + "  ", v.case4_wj);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MULTIPLE_TURTLEBOTS_ESTM_MESSAGE_SYNCMSG_H
